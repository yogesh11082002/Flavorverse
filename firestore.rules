/**
 * @fileoverview Firestore Security Rules for FlavorVerse.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, owner-centric model for user data and content creation,
 * while allowing public read access to dishes.  User data is private, dish content is public,
 * and only authenticated users can create or modify content.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data, accessible only to the owning user.
 * - /dishes/{dishId}: Stores dish information, publicly readable but writable only by the creator.
 * - /dishes/{dishId}/comments/{commentId}: Stores comments for each dish; creation is open to all authenticated users.
 * - /dishes/{dishId}/likes/{userId}: Each document represents the like from a user (userID). Accessible only by the user.
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect user privacy.
 * - Dishes are publicly readable to enable browsing without authentication.
 * - Write access to dishes is restricted to the dish creator (owner-only writes).
 * - All write operations require authentication.
 *
 * Denormalization for Authorization:
 * - The `Dish` document includes a `userId` field to quickly check ownership for update and delete operations, avoiding costly `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the owning user can read or write their own profile.
     * @path /users/{userId}
     * @allow (get, create, update, delete, list) if the user's auth UID matches the userId.
     * @deny (get, create, update, delete, list) if the user's auth UID does not match the userId.
     * @principle Enforces strict user ownership and prevents unauthorized access to user data.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId) && existsAfter(/databases/$(database)/documents/users/$(userId));
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is disabled for privacy.
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to dishes while restricting write access to the dish creator.
     * @path /dishes/{dishId}
     * @allow (get, list) any unauthenticated user to read dish information.
     * @allow (create) only the authenticated user who matches the userId in the document can create the dish.
     * @allow (update, delete) only the user who created the dish can modify or delete it.
     * @deny (create, update, delete) if the user is not authenticated or doesn't match the dish's userId.
     * @principle Implements public read with owner-only writes for shared content.
     */
    match /dishes/{dishId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isDishOwner() {
        return isSignedIn() && request.auth.uid == resource.data.userId;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isDishOwner();
      allow delete: if isDishOwner();
    }

    /**
     * @description Allows authenticated users to create comments on dishes. Anyone can read the comments.
     * @path /dishes/{dishId}/comments/{commentId}
     * @allow (get, list) any unauthenticated user to read comments on dishes.
     * @allow (create) any authenticated user to create a comment.
     * @deny (update, delete) any user from updating or deleting comments.
     * @principle Allows public comments with no modifications.
     */
    match /dishes/{dishId}/comments/{commentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

       /**
        * @description Secure likes subcollection. Only the owning user can read or write their own like.
        * @path /dishes/{dishId}/likes/{userId}
        * @allow (get, create, update, delete, list) if the user's auth UID matches the userId (document ID).
        * @deny (get, create, update, delete, list) if the user's auth UID does not match the userId (document ID).
        * @principle Enforces strict user ownership and prevents unauthorized access to like data.
        */
       match /dishes/{dishId}/likes/{userId} {
            function isSignedIn() {
              return request.auth != null;
            }

            function isOwner(userId) {
              return request.auth.uid == userId;
            }

            function isExistingOwner(userId) {
              return isSignedIn() && isOwner(userId) && existsAfter(/databases/$(database)/documents/dishes/$(dishId)/likes/$(userId));
            }

            allow get: if isOwner(userId);
            allow list: if false;
            allow create: if isSignedIn() && isOwner(userId);
            allow update: if isExistingOwner(userId);
            allow delete: if isExistingOwner(userId);
        }
  }
}